package basicOperators;

import com.google.common.collect.ImmutableList;
import io.reactivex.rxjava3.core.Observable;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Accumulates all emissions into a collection such as a List or Map and returns
 * that entire collection as a single value.
 * <p>
 * Caution! Avoid reducing a stream of items into collections for the sake of it.
 * It can undermine the benefits of reactive programming where items are processed in a
 * beginning-to-end, one-at-a-time sequence. You only want to aggregate the emitted items
 * into a collection when you need to group them logically in some way.
 */
public class CollectionOperators {
    private final Observable<String> dateSource = Observable.just("1/3/2016", "5/9/2018", "7/12/2020");
    private final Observable<String> stringSource = Observable.just("Alpha", "Beta", "Gamma", "Beta");
    private final Observable<Integer> numericSource = Observable.just(15, 2, 371, 232, 1, 1000, 312);

    /**
     * Collects incoming items into a List<T> and then pushes that list object as a Single<List<T>>.
     * By default, uses an ArrayList implementation. You can optionally specify an integer argument to serve
     * as the capacityHint value that optimizes the initializations of the ArrayList to expect roughly that
     * number of items.
     * If you want to use different List implementation, you can provide a Callable function as an
     * argument to specify one.
     */
    public final void toList() {
        var formatter = DateTimeFormatter.ofPattern("d/M/yyyy");
//        1) simple
        dateSource.map(item -> LocalDate.parse(item, formatter))
                .toList()
                .subscribe(System.out::println);
//        2) With capacity hint
        dateSource.map(item -> LocalDate.parse(item, formatter))
                .toList(16)
                .subscribe(System.out::println);
//        3) With another list implementation
        dateSource.map(item -> LocalDate.parse(item, formatter))
                .toList(CopyOnWriteArrayList::new)
                .subscribe(System.out::println);

    }

    /**
     * It collects the emitted values into a List object that has the elements sorted
     * in a natural order(based on their Comparable implementation).
     * As with sorted() operator, you can provide a Comparator as aan argument to apply a
     * different sorting logic.
     * You can also specify an initial capacity for the backing ArrayList, just like in the
     * case of the toList() operator.
     */
    public final void toSortedList() {
        numericSource.toSortedList(16)
                .subscribe(System.out::println);
    }

    /**
     * Collects received values into Map<K,T>, where K is the key type.
     * The key is generated by the Function<T,K> function provided as
     * the argument.
     * If you want to yield a different value other than the received one to
     * associate with the key.
     * By default, uses HashMap, but you can change the implementation of Map interface.
     * Note that if there is a key that map to multiple received values, the last value
     * for that key is going to replace the previous ones.
     */
    public final void toMap() {
//        1) Map<Char, String>, where each string is keyed off their first character
        stringSource.toMap(str -> str.charAt(0))
                .subscribe(System.out::println);
//        2) Map<Char, Integer>
        stringSource.toMap(str -> str.charAt(0), String::length)
                .subscribe(System.out::println);
//        3)ConcurrentHashMap
        stringSource.toMap(str -> str.charAt(0), String::length, ConcurrentHashMap::new)
                .subscribe(System.out::println);
    }

    /**
     * If you want a given key to map to multiple values, you can use toMultiMap() instead
     * toMap(), which maintains a list of corresponding values for each key.
     */
    public final void toMultiMap() {
        stringSource.toMultimap(str -> str.charAt(0), String::length, ConcurrentHashMap::new)
                .subscribe(System.out::println);
    }

    /**
     * When none of the collection operators can do what you need you can always use the collect()
     * operator to specify a different type to collect items into.
     * When you need to collect values in a mutable object, and you need a new mutable object
     * seed each time, use collect() instead of reduce() operator.
     */
    public final void collect() {
//        1)  implementing toSet
        stringSource.collect(HashSet<String>::new, HashSet::add)
                .subscribe(System.out::println);
//        2) Guava immutable list
        stringSource.collect(ImmutableList::builder, ImmutableList.Builder::add)
                .map(ImmutableList.Builder::build)
                .subscribe(System.out::println);
    }
}
